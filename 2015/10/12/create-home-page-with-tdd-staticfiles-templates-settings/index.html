<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <link rel="stylesheet" href="/css/main.css" type="text/css">
    <link rel="stylesheet" href="/css/style.css" type="text/css">
    
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
    <link rel="shortcut icon" href="/images/avatar.png">

    
    <title>第三部分--以TDD的方式，配置Staticfiles和Templates来创建一个主页</title>
</head>

<body>

<p>搭建好工作环境后，我们就可以把目光聚焦到创建站点主页这事儿上啦。</p>
<p>然而，这将不会在是一个只有“hello world”的空白主页。</p>
<p>我们将配置static和templates文件，并使用<code>HTML5 样板文件</code>和<code>Twitter Bootstrap</code>来创建一个更好的主页（当然，它也会有hello world）</p>
<p>另外，我们将遵循Testing Goat，按照TDD的理念来创建主页。通过本教程你将学到很多东西！ :-)</p>
<p>我们将讲述下列内容：</p>
<hr>
<h3 id="静态文件配置">静态文件配置</h3><p>打开通用的<code>settings.py</code>文件（即<code>base.py</code>），找到<code>INSTALLED_APPS</code>变量。确保<code>django.contrib.staticfiles</code>在这个变量里。</p>
<p>然后跳转到文件最后，找到下面的内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br></pre></td></tr></table></figure>
<p>这行代码告诉Django去每一个app的static文件夹下找静态文件。</p>
<p>然而，有些静态文件在整个项目里可以通用，所以它们不应该搁在特定的app里。进入<code>taskbuster</code>文件夹，在其中创建一个名为<code>static</code>的文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> taskbuster</span><br><span class="line">$ mkdir static</span><br></pre></td></tr></table></figure></p>
<p>这个目录中将包含所有项目通用的静态文件，比如CSS或javascript文件。</p>
<p>如果你跳转到文件开头，你可以找到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(__file__))</span><br></pre></td></tr></table></figure></p>
<p>这个变量指向实际文件的祖父目录，例如这里是<code>taskbuster</code>文件夹。</p>
<blockquote>
<p>注意：如果你在taskbuster下使用单独的<code>settings.py</code>（即没有settings文件夹），那么你需要重新定义<code>BASE_DIR</code>，以指向<code>taskbuster</code>文件夹。这是因为没有额外的<code>settings</code>文件夹在中间，之前的<code>BASE_DIR</code>将指向<code>taskbuster_project</code>文件夹，而不是<code>taskbuster</code>文件夹。你应该这样重定义它：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>为了告诉Django到我们刚创建的<code>taskbuster/static</code>目录下找静态文件，请在<code>STATIC_URL</code>后面添加下面的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STATICFILES_DIRS = (</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">"static"</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>别忘了后面的逗号<code>,</code>，Django会从每一个app下的static文件夹和<code>taskbuster/static</code>中寻找静态文件。</p>
<h3 id="模板设置">模板设置</h3><p>我们需要对templates做类似的事情。默认地，Django模板加载器将从每一个app下的templates文件夹寻找模板。</p>
<p>但我们先在<code>taskbuster</code>文件夹下创建用于整个项目使用的通用文件的模板文件夹，如<code>base.html</code>或一些错误页面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> taskbuster</span><br><span class="line">$ mkdir templates</span><br></pre></td></tr></table></figure></p>
<p>然后，更新设置文件（<code>base.py</code>），并在<code>TEMPLATE</code>变量里更改<code>DIRS</code>键：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Templates files</span></span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">"templates"</span>)],</span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="keyword">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>跟静态文件一样，Django将从每一个app的<code>templates</code>文件夹下和<code>taskbuster/templates</code>寻找模板文件。</p>
<h3 id="Initializr:_HTML5_样板文件_和_Twitter_Bootstrap">Initializr: HTML5 样板文件 和 Twitter Bootstrap</h3><p>为了测试下模板和静态文件是否能正常工作，并且也因为我喜欢在开发Django时使用一些CSS，我们将使用<code>HTML5 样板文件</code>和<code>Bootstrap</code>。这些工具将帮你创建能在不同的浏览器下工作的模板。</p>
<p>这里，我们选择使用<a href="http://www.initializr.com/" target="_blank" rel="external">Initializr</a>，一个包含<code>HTML5 样板文件</code>和<code>Bootstrap</code>的混合版本。进入其官网，选择你的项目所需要的内容。本项目使用的配置如图所示（在本项目中不会用到Apple Touch Icons）</p>
<p><img src="http://www.marinamele.com/wp-content/uploads/2014/09/taskbuster_part2_initializr.png" alt="Initializr"></p>
<p>下载了压缩包后，将其解压，并重新组织它的内容：</p>
<ul>
<li>将<code>index.html</code>，<code>404.html</code>，<code>humans.txt</code>和<code>robots.txt</code>移至<code>taskbuster/templates</code>文件夹内</li>
<li>将<code>index.html</code>重命名为<code>base.html</code>。index文件常用做主页的模板，但是我们将使用它作为一个基础模板–我们所有的站点模板将继承自这个基础模板。</li>
<li>将其它的文件和文件夹移至<code>taskbuster/static</code>文件夹内</li>
<li>如果你一个你想给你的app使用的icon，请使用它替换掉<code>favicon.ico</code>文件（我推荐你使用相同的名字）。</li>
</ul>
<h3 id="以TDD方式构建主页–测试先行">以TDD方式构建主页–测试先行</h3><p>要确定静态文件和模板是否成功加载，我们需要一个测试。而你知道的…听Testing Goat的话！测试先行，测试先行！</p>
<p><img src="http://www.marinamele.com/wp-content/uploads/2014/08/obey_the_testing_goat-1024x991.jpg" alt="Obey the testing goat"></p>
<p>实际上，真正的TDD开发，我们在设置模板和静态文件之前就应该进行测试。但我想先把配置文件完成。</p>
<p>首先，我们需要把<code>functional_tests</code>文件夹变成一个包，很简单，往里面添加一个<code>__init__.py</code>文件即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch functional_tests/__init__.py</span><br></pre></td></tr></table></figure></p>
<p>这样，我们就可以通过如下方式运行我们的功能测试了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py <span class="built_in">test</span> functional_tests</span><br></pre></td></tr></table></figure></p>
<p>然而，测试工具只会找那些以<code>test</code>开头的文件来运行，因此我们需要把<code>all_user.py</code>重命名为<code>test_all_users.py</code>。</p>
<p>我们让git来做这事，这样方便仓库能够正确地探测到这些改变：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv functional_lists/all_users.py functional_tests/<span class="built_in">test</span>_all_users.py</span><br></pre></td></tr></table></figure></p>
<p>在<code>tb_dev</code>环境下运行开发服务器，然后在<code>tb_test</code>环境下运行这些测试。它们应该跟往常一样正常运行，没有什么有问题的地方！</p>
<p>但我知道你肯定不喜欢同时在两个环境下干活，对吧？我的意思是说在<code>tb_dev</code>下运行服务器，在<code>tb_test</code>下运行测试。为什么不能在测试环境下运行服务器呢？</p>
<p>另外，这些功能测试造成的变化是持久的。想象一下在某一个测试中，我们创建一个model的实例（比如，一个新用户）。我们希望在测试完成后，这个用户实例可以从我们的数据库中消失，对吧？但是对于这些功能测试，我们只是运行了开发服务器，并捣腾了下开发数据库，因此这些变化在测试完成后还将存留。</p>
<p>但不用担心，<code>LiveServerTestCase</code>类会让我们的生活更轻松！ :-)</p>
<p>我们将会看到，这个类的实例将会创建一个带有测试数据库的服务器，就像我们运行单元测试一样。</p>
<p>现在，让我们编辑<code>functional_tests/test_all_users.py</code>，看看模板和静态文件是否正常工作。例如，我们可以测试这俩不同的事情。</p>
<ul>
<li>主页标题是“TaskBuster”</li>
<li>h1的文字颜色是rgba(200, 50, 255, 1)，即粉红色。</li>
</ul>
<p>那我们就开始创建这个测试吧！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.firefox <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> django.core.urlresolvers <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.contrib.staticfiles.testing <span class="keyword">import</span> LiveServerTestCase  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeNewVisitorTest</span><span class="params">(LiveServerTestCase)</span>:</span> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.browser = webdriver.WebDriver()</span><br><span class="line">        self.browser.implicitly_wait(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.browser.quit()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_full_url</span><span class="params">(self, namespace)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.live_server_url + reverse(namespace)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_home_title</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.browser.get(self.get_full_url(<span class="string">"home"</span>))</span><br><span class="line">        self.assertIn(<span class="string">"TaskBuster"</span>, self.browser.title)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_h1_css</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.browser.get(self.get_full_url(<span class="string">"home"</span>))</span><br><span class="line">        h1 = self.browser.find_element_by_tag_name(<span class="string">"h1"</span>)</span><br><span class="line">        self.assertEqual(h1.value_of_css_property(<span class="string">"color"</span>), </span><br><span class="line">                         <span class="string">"rgba(200, 50, 255, 1)"</span>)</span><br></pre></td></tr></table></figure></p>
<p>现在我们来过一遍这些代码：</p>
<ul>
<li>首先，我们定义了一个<code>get_full_url</code>辅助函数，它接收一个<code>namespace</code>参数<ul>
<li><code>namespace</code>是一个url的标识符。这对Django来说是个好事儿：当你有了这些标识符，你可以把url变成你想要的，并且代码仍将正常工作。</li>
<li><code>self.live_server_url</code>提供给你本地主机的url。我们使用这个方法是因为服务器使用另外一个url（通常是<code>http://127.0.0.1:8021</code>），而这个方法更灵活。</li>
<li><code>reserve</code>提供给定的<code>namespace</code>的相对url，这里是<code>/</code></li>
<li>函数最终返回给你这个<code>namespace</code>的绝对url（前两者之和），即<code>http://127.0.0.1:8021/</code>。</li>
</ul>
</li>
<li><code>test_home_title</code>函数用来测试主页标题是否含有<code>TaskBuster</code>这个单词。我们将为此创建一个模板，因此如果标题存在就将意味着模板正确地加载了。</li>
<li><code>test_h1_css</code>函数用来测试<code>h1</code>是否显示了我们想要的颜色。文字颜色的CSS定义将写入一个CSS文件中，这意味着如果测试通过，则静态文件正确地加载了。</li>
<li>最后，注意我们已经把<code>if __name__ == &#39;__main__&#39;</code>这条语句给删了，因为<code>functional_tests</code>已经是个可以跟Django的测试工具运行的包啦。</li>
</ul>
<p>创建完我们的测试，TDD告诉我们进行下面的循环操作：</p>
<ul>
<li>运行测试，看它是否会失败</li>
<li>写一些代码来纠正这些测试的错误信息（只写用来纠正测试失败所提示的那些错误信息的代码，不用涉及到其他可能的错误）</li>
</ul>
<p>我们必须遵从这些循环操作，直到测试通过。在下个章节你将对这些概念有个更清楚的认识。</p>
<h3 id="以TDD方式构建主页–然后编码">以TDD方式构建主页–然后编码</h3><p>现在我们已经为我们的主页创建了功能测试，我们运行下它，看看它是怎么失败的。在<code>tb_test</code>环境下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py <span class="built_in">test</span> functional_tests</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到第一个错误是“home”没有定义。打开<code>taskbuster/urls.py</code>，然后从<code>views.py</code>中导入<code>home</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> home</span><br></pre></td></tr></table></figure></p>
<p>注意这里我们使用了一个相对导入来导入<code>home</code>视图。这样我们可以不用担心当改变我们项目或应用名称时会破坏urls。</p>
<p>下一步，添加下面的url：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    url(<span class="string">r'^$'</span>, home, name=<span class="string">'home'</span>),</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>如果再次运行测试，它仍将失败，因为我们还没有定义任何的<code>home</code>视图。我们来定义一个简单的，打开<code>taskbuster/views.py</code>，写入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">(request)</span>:</span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">""</span></span><br></pre></td></tr></table></figure></p>
<p>仍然会有一个测试失败，因为我们主页标题中没有<code>TaskBuster</code>。</p>
<p>现在让我们开始捣腾咱们的模板：用浏览器打开<code>taskbuster/templates/base.html</code>，看看它长个啥样。很恶心对不对？这是因为我们的静态文件还没有加载。</p>
<p><code>base.html</code>将作为我们的基础模板，其他项目的模板将继承它，包括主页。</p>
<p>那么，让我们开始单元测试吧。额，我知道你只想写个主页模板代码，不是你知道的，我们要听<code>Testing Goat</code>的话！ :-)</p>
<p>单元测试是用来从开发者的角度来测试代码的小片段。比如，我们都知道用户并不关心主页模板是不是继承至其他模板，只要他能看到他想看的内容就好。但是开发者关心这事儿，所以我们应该写单元测试。并且我意识到当我必须思考测试的时候，我写出的代码更整洁。我想这是因为写测试能让你思考你的代码真正想做的事。而这将使你头脑清醒。:-)</p>
<p>在<code>taskbuster</code>文件夹下创建<code>test.py</code>文件，并写入下面的测试代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> TestCase</span><br><span class="line"><span class="keyword">from</span> django.core.urlresolvers <span class="keyword">import</span> reverse</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestHomePage</span><span class="params">(TestCase)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_uses_index_template</span><span class="params">(self)</span>:</span></span><br><span class="line">        response = self.client.get(reverse(<span class="string">"home"</span>))</span><br><span class="line">        self.assertTemplateUsed(response, <span class="string">"taskbuster/index.html"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_uses_base_template</span><span class="params">(self)</span>:</span></span><br><span class="line">        response = self.client.get(reverse(<span class="string">"home"</span>))</span><br><span class="line">        self.assertTemplateUsed(response, <span class="string">"base.html"</span>)</span><br></pre></td></tr></table></figure></p>
<p>你可以这样运行这些测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py <span class="built_in">test</span> taskbuster.test</span><br></pre></td></tr></table></figure></p>
<p>很显然，它们将失败…首先，让我们创建<code>taskbuster/index.html</code>模板：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> taskbuster/templates</span><br><span class="line">$ mkdir taskbuster</span><br><span class="line">$ touch taskbuster/index.html</span><br></pre></td></tr></table></figure></p>
<p>并编辑<code>taskbuster/views.py</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"taskbuster/index.html"</span>, &#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>代码里面的<code>render</code>方法，可以让你加载一个模板，创建一个可以添加一堆变量的上下文，比如当前登录用户的信息，或者当前的语言，然后渲染它，并返回一个<code>HttpResponse</code>对象，这一切都在<code>render</code>方法里实现。注意：默认添加的信息依赖于你在设置文件中设置的模板上下文处理器。</p>
<p>如果你再次运行单元测试，你将发现第一个测试通过了，这表明主页已经使用了<code>taskbuster/index.html</code>模板。我们只需要让这个模板继承至<code>base.html</code>模板。</p>
<p>那么让我们编辑下<code>base.html</code>。现在，我们只对head标签里面的title标签感兴趣。在文件中找到它，并写下下面的内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>&#123;% block head_title %&#125;&#123;% endblock %&#125;<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>{% block head_title %}</code>和<code>{% endblock %}</code>这两个模板标签用来标记内容块的起始，这些内容可以在子模板中被替换掉。下一分钟你就回明白这一点了。</p>
<p>再次编辑<code>index.html</code>，让它继承至<code>base.html</code>，然后给它加个标题：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends "base.html" %&#125;</span><br><span class="line">&#123;% block head_title %&#125;TaskBuster Django Tutorial&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>index.html</code>包含<code>base.html</code>除了有这些特殊标签的代码块之外的所有内容。这种情况下，它把<code>index.html</code>的模板标签内容替换成<code>base.html</code>中相应的代码块即可。</p>
<p>让我们再次运行单元测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py <span class="built_in">test</span> taskbuster.test</span><br></pre></td></tr></table></figure></p>
<p>很好…！！太棒了，测试全都通过了！</p>
<p>那么功能测试呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py <span class="built_in">test</span> functional_tests</span><br></pre></td></tr></table></figure></p>
<p>一个通过，一个失败。这有问题呀！但是我们还是需要处理下静态文件先！</p>
<p>首先，让我们自定义我们的CSS文件，编辑<code>taskbuster/static/main.css</code>文件，添加：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.jumbotron</span> <span class="tag">h1</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">200</span>, <span class="number">50</span>, <span class="number">255</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>然后，再次编辑<code>base.html</code>，把下面的代码加入到文件开头（甚至可以在<code>&lt;!DOCTYPE html&gt;</code>声明之前）：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load staticfiles %&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，找到所有链接静态文件的标签以及包含javascript的脚本标签：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"css/xxx.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"js/xxx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>把它们变成这个样子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"&#123;% static 'css/xxx.css' %&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"&#123;% static 'js/xxx.js' %&#125;"</span>&gt;</span><span class="undefined"></span></span><br></pre></td></tr></table></figure></p>
<p>小心处理<code>&quot;&quot;</code>和<code>&#39;&#39;</code>。另外，在文件最后你将看到这样的东西：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.write('<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"js/vendor/jquery-1.11.0.min.js"</span>&gt;</span><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="title">\</span>/<span class="attribute">script</span>&gt;</span>')</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们不能添加<code>{% static "xxx" %}</code>标签，因为这会破坏它所在的字符串。这种情况，你可以加入静态文件指定相对路径：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.write('<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"static/js/vendor/jquery-1.11.0.min.js"</span>&gt;</span><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="title">\</span>/<span class="attribute">script</span>&gt;</span>')</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意：虽然导入静态文件的方法都可以正常工作，但如果你计划使用内容分发网络（CDN）来处理静态文件，那么你最好使用模板标签。</p>
<p>Ok，让我们再次运行测试！Oh 不！我遇到了一个之前没有的错误！</p>
<p>这是因为<code>LiveServerTestCase</code>不支持静态文件…</p>
<p>但请不用担心，跟往常一样，Django自有妙计！我有另外一个测试类可以支持静态文件！</p>
<p>编辑<code>functional_tests/test_all_users.py</code>文件，去除带有<code>-</code>号的行，增加带有<code>+</code>号的行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">from</span> django.test <span class="keyword">import</span> LiveServerTestCase</span><br><span class="line">+ <span class="keyword">from</span> django.contrib.staticfiles.testing <span class="keyword">import</span> StaticLiveServerTestCase</span><br><span class="line"></span><br><span class="line">- <span class="class"><span class="keyword">class</span> <span class="title">HomeNewVisitorTest</span><span class="params">(LiveServerTestCase)</span>:</span></span><br><span class="line">+ <span class="class"><span class="keyword">class</span> <span class="title">HomeNewVisitorTest</span><span class="params">(StaticLiveServerTestCase)</span>:</span></span><br></pre></td></tr></table></figure></p>
<p>再次运行你的测试，啊哈，它们都通过啦！ :-)</p>
<p>如果你要同时运行单元测试和功能测试，你可以这样子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p>你可以打开本地链接，看看正确加载了CSS文件的主页是多么的漂亮！:-)</p>
<p>…虽然对于h1的字体颜色来说可能不是最好的选择！</p>
<p>注意：如果你运行功能测试，遇到说浏览器在连接之前已经退出了的错误信息，请尝试在你的工作环境中升级selenium：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -U selenium</span><br></pre></td></tr></table></figure></p>
<p>这应该可以解决你的问题 :-)</p>
<h3 id="再次把代码提交到本地仓库和Bitbucket">再次把代码提交到本地仓库和Bitbucket</h3><p>是时候进行下一个提交了！<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git status</span><br></pre></td></tr></table></figure></p>
<p>确保你只添加了你想提交的文件。另外，在输出的开头会显示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span></span><br></pre></td></tr></table></figure></p>
<p>这意味着实际的主分支更Bitbucket中的原始分支状态一致。让我们看看在提交新的改变之后会发生什么：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"Settings, static files and templates"</span></span><br></pre></td></tr></table></figure></p>
<p>让我们再次查看状态…<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by <span class="number">1</span> commit.</span><br><span class="line">(use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure></p>
<p>因此本地主分支领先原始主分支一个提交。让我们把最近的提交推送到Bitbucket仓库来修复这个问题：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>那么现在我们的分支又跟Bitbucket上的<code>origin/master</code>同步了。</p>
<p>这部分要讲的就这么多，我们已经创建了一个不错的主页啦！</p>
<p>在下一部分，我们将讨论配置其他从<code>Initializr</code>包下载的文件：<code>robots.txt</code>， <code>humans.txt</code>和<code>favicon.ico</code></p>
<p>另外，我将告诉你如果使用<code>coverage</code>，一个用于衡量测试覆盖的代码量工具。</p>
<p>下一部分：<a href="http://www.marinamele.com/taskbuster-django-tutorial/taskbuster-django-tutorial/template-inheritance-website-files-and-testing-with-coverage" target="_blank" rel="external">网站文件和使用<code>coverage</code>进行测试</a></p>
<p>请记得跟你的朋友分享本教程！ :-)</p>






</body>
</html>